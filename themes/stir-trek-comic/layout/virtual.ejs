<section>
    <style>
        .virtualSessionRow .virtualSession{
            font-size: 0px;
            text-align: center;
            margin-bottom: 20px;

        }
        .virtualSessionRow .virtualSession p {
            font-size: 18px;
            margin-top: 0px;
        }

        .virtualSessionRow p.sessionTitle {
            font-size: 18px;
        }

        .virtualSessionRow p.sessionSpeakers {
            font-size: 14px;
        }

        .flex-container {
            display: -ms-flexbox;
            display: -webkit-flex;
            display: flex;
            -webkit-flex-direction: row;
            -ms-flex-direction: row;
            flex-direction: row;
            -webkit-flex-wrap: wrap;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            -webkit-justify-content: center;
            -ms-flex-pack: center;
            justify-content: center;
            -webkit-align-content: stretch;
            -ms-flex-line-pack: stretch;
            align-content: stretch;
            -webkit-align-items: flex-start;
            -ms-flex-align: start;
            align-items: flex-start;
        }

    .flex-item {
        -webkit-order: 0;
        -ms-flex-order: 0;
        order: 0;
        -webkit-flex: 0 1 auto;
        -ms-flex: 0 1 auto;
        flex: 0 1 auto;
        -webkit-align-self: auto;
        -ms-flex-item-align: auto;
        align-self: auto;
        width: 33%;
    }
    @media screen and (max-width: 991px) {
        .flex-item {
            width: 50%;
        }
    }
    @media screen and (max-width: 650px) {
        .flex-item {
            width: 100%;
        }
    }
    </style>
    <% 
        
    // Get the evals() out of the way since they are gross
    var scheduleData = eval("site.data.schedule" + config.currentYear + ".scheduledSessions");
    var sessionAndSpeakerData = eval("site.data.sessions" + config.currentYear);

    if(sessionAndSpeakerData && config.showSchedule) {
        // Categories are buried a layer
        var allCategories = sessionAndSpeakerData.categories.find(c => c.title === "Track").items;

        // Hack to filter out breakfast and lunch
        for (var timeSlot of scheduleData.timeSlots.reverse() ) { 
            if(timeSlot.time === "7:30 AM" || timeSlot.time === "12:00 PM") continue;

            %>
            <div class="row virtualSessionRow">
                <div class="col-md-12">
                    <div class="comic-panel-header offset comic-panel-gold">
                        <%= timeSlot.time %>
                    </div>
                    <div class="comic-panel-body with-header flex-container">                
                        <% for (var sessionSlot of timeSlot.sessions) { 
                            
                            // Search for the sessions id from the sessionize feed to match our session
                            var sessionInfo = sessionAndSpeakerData.sessions.find(x => x.id === sessionSlot.id.toString() );
                            
                            // Find the speaker sessionInfo
                            var allSpeakersInfo = sessionAndSpeakerData.speakers.filter(x => sessionInfo.speakers.includes(x.id))

                            if(allSpeakersInfo.length > 0) { 
                                let createSpeakerUrl = (firstName, lastName) => {
                                    return `/speakers/${config.currentYear}/${firstName.replace(/[ \"]/g,"")}-${lastName.replace(/[ \"]/g,"")}.html`
                                }

                                // Store additional speakers if any
                                let allSpeakers = [];
                                allSpeakersInfo.forEach(speaker => {
                                    allSpeakers.push({
                                        firstName: speaker.firstName,
                                        lastName: speaker.lastName,
                                        speakerPageUrl: createSpeakerUrl(speaker.firstName, speaker.lastName)
                                    });
                                })

                                // Parse the YouTube UID so we can use it in our embeds
                                var regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
                                let youTubeUniqueId;
                                if(sessionInfo.recordingUrl) {
                                    var match = sessionInfo.recordingUrl.match(regExp);
                                    youTubeUniqueId = (match&&match[7].length==11)? match[7] : false;
                                } else {
                                    const exampleIds = ["OsULvjLTyXw", "8Qn4fTQdErQ", "5GWQv6TIGug"];

                                    const randomId = Math.floor(Math.random() * exampleIds.length);
                                    youTubeUniqueId = exampleIds[randomId] // Temp hack to make this work for layout
                                }

                                if(youTubeUniqueId) {
                                %>
                                <div class="virtualSession flex-item" style="display: inline-block; vertical-align: top;">
                                    <iframe width="224" height="126" 
                                        src="https://www.youtube-nocookie.com/embed/<%= youTubeUniqueId %>" 
                                        srcdoc="<style>*{padding:0;margin:0;overflow:hidden}html,body{height:100%}img,span{position:absolute;width:100%;top:0;bottom:0;margin:auto}span{height:1.5em;text-align:center;font:48px/1.5 sans-serif;color:white;text-shadow:0 0 0.5em black}</style><a href=https://www.youtube-nocookie.com/embed/<%= youTubeUniqueId %>?autoplay=1><img src=https://img.youtube.com/vi/<%= youTubeUniqueId %>/hqdefault.jpg><span>â–¶</span></a>"
                                        title="YouTube video player" frameborder="0" 
                                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>
                                    <p class="sessionTitle">                                        
                                        <a href="<%= allSpeakers[0].speakerPageUrl %>#abstract">
                                            <%= sessionInfo.title %>
                                        </a>
                                    </p>
                                    <p class="sessionSpeakers">
                                        <% 
                                            allSpeakers.forEach(thisSpeaker => {
                                        %>
                                            <a href="<%= thisSpeaker.speakerPageUrl %>">
                                                <%= thisSpeaker.firstName + " " + thisSpeaker.lastName %>
                                            </a><br>
                                        <% }); %>

                                        <% var thisCategory = allCategories.find(c => c.id === sessionInfo.categoryItems[0]); %>
                                        <%= thisCategory.name %>
                                    </p>
                                </div>
                                <% } %>
                            <% } %>
                        <% } %>
                        <div style="clear: both;"></div>
                    </div>
                </div>
            </div>
        <% } %>
    <% } %>
</section>

<script src="/scripts/luxon.min.js"></script>
<script>
    var DateTime = luxon.DateTime;
    
    // Hey! You! Yeah you!
    // If you're reading this then you're an 31337 h4x0r. Please don't share this. 
    // We're trying to make a virtual event available due to COVID without spending a thousand hours building something we'll hopefully never use again.
    // It's our little secret. Ssshhhh :)
    const secretAuthorizationCookie = "UltraSecureVirtualLogin";

    function setCookie(name, value) {
    document.cookie = name +'='+ value +'; path=/virtual; expires=Tue, 19 Jan 2038 04:14:07 GMT';
    }
    function deleteCookie(name) {
    document.cookie = name +'=; path=/virtual; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
    }

    function isUserLoggedIn() {
        // We don't even care what the cookie says. We don't believe in 0-trust systems. 98-trust all the way!
        if (!document.cookie.split('; ').find(row => row.startsWith(secretAuthorizationCookie))) {
            return false;
        } else {
            return true;
        }
    }

    function logout() {
        deleteCookie(secretAuthorizationCookie);
    }

    function promptUserForPassword(numberOfTries) {
        if(!numberOfTries) numberOfTries = 0; // handle the default state
        console.log(numberOfTries);

        if(numberOfTries === 3) {
            alert("Please check your Eventbrite order / ticket number and try again!");
            return;
        }
        
        let userAuthenticationAttempt = prompt("Please enter your Eventbrite order / ticket number to login.");

        let sophisticatedSecurityAlgorithm = /^[a-zA-Z0-9]{10}$/;

        if(userAuthenticationAttempt.match(sophisticatedSecurityAlgorithm)){
            if(userAuthenticationAttempt === "1234567890") {
                alert("Hey, quit trying to be funny!");
                return;
            }

            setCookie(secretAuthorizationCookie, "authorized");
        } else {
            promptUserForPassword(numberOfTries + 1);
        }

    }

    function setupRevealTimer() {

        let stirTrekYear = 2022;
        let stirTrekMonth = 5
        let stirTrekDay = 6

        const eventTimes = [
            DateTime.fromObject({year: stirTrekYear, month: stirTrekMonth, day: stirTrekDay, hour: 8, minute: 30 }, { zone: 'America/New_York'}),
            DateTime.fromObject({year: stirTrekYear, month: stirTrekMonth, day: stirTrekDay, hour: 9, minute: 45 }, { zone: 'America/New_York'}),
            DateTime.fromObject({year: stirTrekYear, month: stirTrekMonth, day: stirTrekDay, hour: 11, minute: 00 }, { zone: 'America/New_York'}),
            DateTime.fromObject({year: stirTrekYear, month: stirTrekMonth, day: stirTrekDay, hour: 1, minute: 0 }, { zone: 'America/New_York'}),
            DateTime.fromObject({year: stirTrekYear, month: stirTrekMonth, day: stirTrekDay, hour: 2, minute: 15 }, { zone: 'America/New_York'}),
            DateTime.fromObject({year: stirTrekYear, month: stirTrekMonth, day: stirTrekDay, hour: 3, minute: 30 }, { zone: 'America/New_York'}),
        ]

        // If the current time is before the first event time, show the event not started prompt

        // If the current time is after any event times, show them all

        // If there are future event times, set a timer to put something on screen when the user should refresh the page
    }

    // Test for whether the user is previously logged in. If they aren't, try to log in them in.
    // Note - this happens synchronously (yay old JavaScript features) so we can just try again after what should be a successful login :)
    if(!isUserLoggedIn()) {
        promptUserForPassword(0);
    }
    // They should be all set now. If not, they'll have to reload the page. Because modern UX.
    if(isUserLoggedIn()) {
    // User is logged in. Kick off the super secret timing.
        setupRevealTimer();
    }


</script>